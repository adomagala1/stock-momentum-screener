import logging
import pandas as pd
import numpy as np
from datetime import date
from supabase import create_client, Client
import streamlit as st


class SupabaseHandler:
    def __init__(self, url: str, key: str):
        if not url or not key:
            raise ValueError("Supabase URL and Key must be provided.")
        self.client: Client = create_client(url, key)
        self._checked_tables = set()

    def check_and_inform(self, table_name: str = "stocks_data") -> bool:
        """
        Sprawdza, czy tabela istnieje. Jeśli nie, wyświetla jasne instrukcje dla użytkownika.
        Zwraca True, jeśli tabela istnieje i jest gotowa do użycia, w przeciwnym razie False.
        """
        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostępna.")
            return True
        except Exception as e:
            logging.warning(f"Tabela '{table_name}' nie istnieje lub jest niedostępna. Błąd: {e}")

            st.error(f"Wymagana tabela '{table_name}' nie istnieje w Twojej bazie danych!", icon="🚨")
            st.warning(
                "**Aby aplikacja mogła zapisywać dane, potrzebna jest jednorazowa konfiguracja.**",
                icon="ℹ️"
            )

            st.markdown("""
            **Prosta instrukcja (zajmie 2 minuty):**
            1.  Przejdź do swojego projektu na [Supabase.com](https://supabase.com/dashboard).
            2.  W menu po lewej stronie kliknij **SQL Editor**.
            3.  Kliknij **+ New query**.
            4.  Skopiuj poniższy blok kodu i wklej go w całości do edytora.
            5.  Kliknij zielony przycisk **RUN**.

            Po wykonaniu tych kroków **odśwież stronę aplikacji**.
            """)

            # Dodano politykę RLS, która pozwala na publiczny dostęp.
            create_table_sql = """
            -- Tworzy wymaganą tabelę do przechowywania danych giełdowych.
            CREATE TABLE IF NOT EXISTS public.stocks_data (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
                ticker TEXT,
                company TEXT,
                sector TEXT,
                industry TEXT,
                country TEXT,
                market_cap NUMERIC,
                p_e NUMERIC,
                price NUMERIC,
                change NUMERIC,
                volume BIGINT,
                import_date DATE
            );

            -- Włącza mechanizm Row Level Security dla tej tabeli (ważne dla bezpieczeństwa)
            ALTER TABLE public.stocks_data ENABLE ROW LEVEL SECURITY;

            -- Usuwa starą politykę, jeśli istnieje, aby uniknąć konfliktu
            DROP POLICY IF EXISTS "Public access for app users" ON public.stocks_data;

            -- Tworzy nową politykę, która pozwala KAŻDEMU (używającemu anon_key)
            -- na wykonywanie wszystkich operacji (SELECT, INSERT, UPDATE, DELETE).
            CREATE POLICY "Public access for app users"
            ON public.stocks_data
            FOR ALL -- Dla wszystkich operacji
            USING (true)
            WITH CHECK (true);
            """
            st.code(create_table_sql, language="sql")
            return False

    def _ensure_table_exists(self, table_name: str):
        if table_name in self._checked_tables:
            return

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostępna.")
            self._checked_tables.add(table_name)
        except Exception:
            st.warning(f"Tabela '{table_name}' nie znaleziona. Próbuję ją automatycznie utworzyć...", icon="🛠️")
            logging.warning(
                f"Tabela '{table_name}' nie znaleziona. Wywołuję RPC 'create_stocks_data_table_if_not_exists'.")

            try:
                self.client.rpc('create_stocks_data_table_if_not_exists', {}).execute()

                st.success(f"Tabela '{table_name}' została pomyślnie utworzona w bazie danych!", icon="✅")
                logging.info(f"RPC zakończone sukcesem. Tabela '{table_name}' powinna już istnieć.")
                self._checked_tables.add(table_name)
            except Exception as rpc_error:
                logging.error(f"Krytyczny błąd podczas wywoływania RPC do tworzenia tabeli: {rpc_error}")
                st.error(
                    f"Nie udało się automatycznie utworzyć tabeli '{table_name}'.",
                    icon="❌"
                )
                st.warning(
                    "Upewnij się, że funkcja `create_stocks_data_table_if_not_exists` została poprawnie dodana w edytorze SQL w panelu Supabase.",
                    icon="ℹ️"
                )
                raise RuntimeError(f"Failed to create table '{table_name}' via RPC.")

    def save_dataframe(self, df: pd.DataFrame, table_name: str = "stocks_data") -> int:
        try:
            self._ensure_table_exists(table_name)
        except RuntimeError as e:
            logging.error(str(e))
            return 0

        if df.empty:
            st.warning("Otrzymano pusty DataFrame. Nic nie zostało zapisane.")
            return 0

        df_to_save = df.copy()
        df_to_save["import_date"] = date.today().isoformat()
        df_to_save = df_to_save.replace({np.nan: None, pd.NaT: None})
        records = df_to_save.to_dict(orient="records")

        saved_count = 0
        batch_size = 500

        st.info(f"Rozpoczynam zapis {len(records)} rekordów do tabeli '{table_name}'...")

        for i in range(0, len(records), batch_size):
            chunk = records[i:i + batch_size]
            try:
                response = self.client.table(table_name).insert(chunk).execute()
                if response.error:
                    st.error(f"Błąd Supabase w trakcie zapisu (batch {i // batch_size + 1}): {response.error.message}")
                    logging.error(f"Supabase insert error: {response.error}")
                    break
                else:
                    saved_count += len(response.data)
            except Exception as e:
                st.error(f"Wystąpił nieoczekiwany błąd sieci lub klienta podczas zapisu: {e}")
                logging.exception("Exception during Supabase insert batch.")
                break

        return saved_count


def clean_and_transform_for_db(df: pd.DataFrame) -> pd.DataFrame:
    """Czyści i przekształca surowy DataFrame z Finviz do wstawienia do bazy danych."""
    if df.empty:
        return df

    df_copy = df.copy()

    df_copy.columns = [col.lower().replace(' ', '_').replace('.', '').replace('/', '_') for col in df_copy.columns]

    def clean_numeric(value):
        if isinstance(value, (int, float)):
            return value
        if isinstance(value, str):
            value = value.strip().replace(',', '')
            if value.endswith('B'): return float(value[:-1]) * 1e9
            if value.endswith('M'): return float(value[:-1]) * 1e6
            if value.endswith('K'): return float(value[:-1]) * 1e3
            if value.endswith('%'): return float(value[:-1])
        return value

    cols_to_process = ['market_cap', 'p_e', 'price', 'change', 'volume']
    for col in cols_to_process:
        if col in df_copy.columns:
            df_copy[col] = df_copy[col].apply(clean_numeric)
            df_copy[col] = pd.to_numeric(df_copy[col], errors='coerce')

    return df_copy.replace({np.nan: None, pd.NaT: None})


def create_user(email: str, password: str, sb_url: str, sb_key: str) -> bool:
    """Tworzy nowego użytkownika w systemie uwierzytelniania Supabase."""
    try:
        sb = SupabaseHandler(sb_url, sb_key)
        response = sb.client.auth.sign_up({"email": email, "password": password})

        if response.user:
            logging.info(f"Użytkownik {email} został pomyślnie zarejestrowany.")
            st.success("Rejestracja pomyślna! Sprawdź email, aby zweryfikować konto.")
            return True
        elif response.error:
            logging.error(f"Błąd przy tworzeniu użytkownika: {response.error.message}")
            st.error(f"Błąd przy tworzeniu użytkownika: {response.error.message}")
            return False
        return False
    except Exception as e:
        logging.exception(f"Wyjątek przy tworzeniu użytkownika: {e}")
        st.error(f"Wystąpił nieoczekiwany błąd: {e}")
        return False
