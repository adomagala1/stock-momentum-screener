# app/db/user_supabase_manager.py
import logging
import pandas as pd
import numpy as np
from datetime import date
from supabase import create_client, Client
import streamlit as st
from sqlalchemy.engine import URL
from sqlalchemy import create_engine

class SupabaseHandler:
    def __init__(self, url: str, key: str):
        if not url or not key:
            raise ValueError("Supabase URL and Key must be provided.")
        self.client: Client = create_client(url, key)
        self._checked_tables = set()

    def create_sqlalchemy_engine(self):
        """
        Tworzy silnik SQLAlchemy na podstawie danych wprowadzonych przez UÅ»YTKOWNIKA
        i zapisanych w st.session_state.
        """
        try:
            # POBIERAMY DANE Z SESJI UÅ»YTKOWNIKA!
            db_user = st.session_state["sb_db_user"]
            db_password = st.session_state["sb_db_password"]
            db_host = st.session_state["sb_db_host"]
            db_port = st.session_state["sb_db_port"]
            db_name = st.session_state["sb_db_name"]

            # Sprawdzamy, czy dane nie sÄ… puste
            if not all([db_user, db_password, db_host, db_port, db_name]):
                st.error("Nie wszystkie dane do poÅ‚Ä…czenia z bazÄ… danych zostaÅ‚y podane w konfiguracji.")
                return None

            db_url = URL.create(
                "postgresql+psycopg2",
                username=db_user,
                password=db_password,
                host=db_host,
                port=db_port,
                database=db_name,
            )
            engine = create_engine(db_url)
            logging.info("PomyÅ›lnie utworzono silnik SQLAlchemy dla Supabase na podstawie danych z sesji.")
            return engine
        except KeyError:
            # Ten bÅ‚Ä…d pojawi siÄ™, jeÅ›li uÅ¼ytkownik jeszcze nie wypeÅ‚niÅ‚ formularza
            st.warning("ProszÄ™ najpierw uzupeÅ‚niÄ‡ i zapisaÄ‡ dane do poÅ‚Ä…czenia z bazÄ… danych w zakÅ‚adce konfiguracyjnej.")
            return None
        except Exception as e:
            st.error(f"Nie udaÅ‚o siÄ™ utworzyÄ‡ poÅ‚Ä…czenia z bazÄ… danych uÅ¼ytkownika: {e}")
            return None
    def check_and_inform(self, table_name: str = "stocks_data") -> bool:
        """
        Sprawdza, czy tabela istnieje. JeÅ›li nie, wyÅ›wietla jasne instrukcje dla uÅ¼ytkownika.
        Zwraca True, jeÅ›li tabela istnieje i jest gotowa do uÅ¼ycia, w przeciwnym razie False.
        """
        create_table_sql = """
        -- Tworzy wymaganÄ… tabelÄ™ do przechowywania danych gieÅ‚dowych.
        CREATE TABLE IF NOT EXISTS public.stocks_data (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
            ticker TEXT,
            company TEXT,
            sector TEXT,
            industry TEXT,
            country TEXT,
            market_cap NUMERIC,
            p_e NUMERIC,
            price NUMERIC,
            change NUMERIC,
            volume BIGINT,
            import_date DATE
        );

        -- WÅ‚Ä…cza mechanizm Row Level Security dla tej tabeli (waÅ¼ne dla bezpieczeÅ„stwa)
        ALTER TABLE public.stocks_data ENABLE ROW LEVEL SECURITY;

        -- Usuwa starÄ… politykÄ™, jeÅ›li istnieje, aby uniknÄ…Ä‡ konfliktu
        DROP POLICY IF EXISTS "Public access for app users" ON public.stocks_data;

        -- Tworzy nowÄ… politykÄ™, ktÃ³ra pozwala KAÅ»DEMU (uÅ¼ywajÄ…cemu anon_key)
        -- na wykonywanie wszystkich operacji (SELECT, INSERT, UPDATE, DELETE).
        CREATE POLICY "Public access for app users"
        ON public.stocks_data
        FOR ALL
        USING (true)
        WITH CHECK (true);
        """

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostÄ™pna.")
            return True
        except Exception as e:
            logging.warning(f"Tabela '{table_name}' nie istnieje lub jest niedostÄ™pna. BÅ‚Ä…d: {e}")

            st.error(f"Wymagana tabela '{table_name}' nie istnieje w Twojej bazie danych!", icon="ğŸš¨")
            st.warning(
                "**Aby aplikacja mogÅ‚a zapisywaÄ‡ dane, potrzebna jest jednorazowa konfiguracja.**",
                icon="â„¹ï¸"
            )

            st.markdown("""
            **Prosta instrukcja (zajmie 2 minuty):**
            1. PrzejdÅº do swojego projektu na [Supabase.com](https://supabase.com/dashboard).
            2. W menu po lewej stronie kliknij **SQL Editor**.
            3. Kliknij **+ New query**.
            4. Skopiuj poniÅ¼szy blok kodu i wklej go w caÅ‚oÅ›ci do edytora.
            5. Kliknij zielony przycisk **RUN**.

            Po wykonaniu tych krokÃ³w **odÅ›wieÅ¼ stronÄ™ aplikacji**.
            """)

            st.code(create_table_sql, language="sql")
            return False

    def _ensure_table_exists(self, table_name: str):
        if table_name in self._checked_tables:
            return

        create_table_sql = """
        CREATE TABLE IF NOT EXISTS public.stocks_data (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
            ticker TEXT,
            company TEXT,
            sector TEXT,
            industry TEXT,
            country TEXT,
            market_cap NUMERIC,
            p_e NUMERIC,
            price NUMERIC,
            change NUMERIC,
            volume BIGINT,
            import_date DATE
        );
        """

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostÄ™pna.")
            self._checked_tables.add(table_name)
        except Exception:
            st.warning(f"Tabela '{table_name}' nie znaleziona. PrÃ³bujÄ™ jÄ… automatycznie utworzyÄ‡...", icon="ğŸ› ï¸")
            logging.warning(f"Tabela '{table_name}' nie znaleziona. WywoÅ‚ujÄ™ RPC 'create_stocks_data_table_if_not_exists'.")

            try:
                self.client.rpc('create_stocks_data_table_if_not_exists', {}).execute()
                st.success(f"Tabela '{table_name}' zostaÅ‚a pomyÅ›lnie utworzona w bazie danych!", icon="âœ…")
                self._checked_tables.add(table_name)
            except Exception as rpc_error:
                logging.error(f"Krytyczny bÅ‚Ä…d podczas wywoÅ‚ywania RPC: {rpc_error}")
                st.error(f"Nie udaÅ‚o siÄ™ automatycznie utworzyÄ‡ tabeli '{table_name}'.", icon="âŒ")
                st.warning("Wklej poniÅ¼szy SQL w Supabase SQL Editor i uruchom go (najbezpieczniejsze).", icon="â„¹ï¸")
                st.code(create_table_sql, language="sql")
                raise RuntimeError(f"Failed to create table '{table_name}' via RPC.")

    def save_dataframe(self, df: pd.DataFrame, table_name: str = "stocks_data") -> int:
        try:
            self._ensure_table_exists(table_name)
        except RuntimeError as e:
            logging.error(str(e))
            return 0

        if df.empty:
            st.warning("Otrzymano pusty DataFrame. Nic nie zostaÅ‚o zapisane.")
            return 0

        df_to_save = df.copy()
        df_to_save["import_date"] = date.today().isoformat()
        df_to_save = df_to_save.replace({np.nan: None, pd.NaT: None})

        for col in ["id", "created_at", "idx"]:
            if col in df_to_save.columns:
                df_to_save.drop(columns=[col], inplace=True)

        valid_columns = [
            "ticker", "company", "sector", "industry", "country",
            "market_cap", "p_e", "price", "change", "volume", "import_date"
        ]
        existing_cols = [col for col in df_to_save.columns if col in valid_columns]
        missing_cols = [col for col in valid_columns if col not in df_to_save.columns]

        if missing_cols:
            st.warning(f"BrakujÄ…ce kolumny w DataFrame: {missing_cols} â€“ zostanÄ… pominiÄ™te.", icon="âš ï¸")
        if extra_cols := [col for col in df_to_save.columns if col not in valid_columns]:
            st.info(f"Kolumny niewystÄ™pujÄ…ce w bazie ({extra_cols}) zostaÅ‚y automatycznie odrzucone.", icon="â„¹ï¸")

        df_to_save = df_to_save[existing_cols]

        records = df_to_save.to_dict(orient="records")
        saved_count = 0
        batch_size = 500

        st.info(f"Rozpoczynam zapis {len(records)} rekordÃ³w do tabeli '{table_name}'...")

        for i in range(0, len(records), batch_size):
            chunk = records[i:i + batch_size]
            try:
                response = self.client.table(table_name).insert(chunk).execute()
                if hasattr(response, "error") and response.error:
                    st.error(f"BÅ‚Ä…d Supabase w trakcie zapisu (batch {i // batch_size + 1}): {response.error.message}")
                    logging.error(f"Supabase insert error: {response.error}")
                    break
                elif hasattr(response, "data"):
                    saved_count += len(response.data)
            except Exception as e:
                st.error(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas zapisu: {e}")
                logging.exception("Exception during Supabase insert batch.")
                break

        if saved_count > 0:
            st.success(f"âœ… Zapisano {saved_count} rekordÃ³w do tabeli '{table_name}'.")
        else:
            st.error("âŒ Zapis nie powiÃ³dÅ‚ siÄ™. SprawdÅº komunikaty o bÅ‚Ä™dach powyÅ¼ej.")

        return saved_count


def clean_and_transform_for_db(df: pd.DataFrame) -> pd.DataFrame:
    """CzyÅ›ci i przeksztaÅ‚ca surowy DataFrame z Finviz do wstawienia do bazy danych."""
    if df.empty:
        return df

    df_copy = df.copy()

    # ğŸ”§ Normalizujemy nazwy kolumn
    df_copy.columns = [
        col.lower().strip().replace(' ', '_').replace('.', '').replace('/', '_').replace('-', '_')
        for col in df_copy.columns
    ]

    # ğŸ” Mapowanie nietypowych nazw kolumn na nasze standardy
    rename_map = {
        "market_cap": "market_cap",
        "marketcapitalization": "market_cap",
        "p_e": "p_e",
        "pe": "p_e",
        "pe_ratio": "p_e",
        "price": "price",
        "last": "price",
        "change": "change",
        "chg": "change",
        "volume": "volume",
        "vol": "volume"
    }
    df_copy.rename(columns=rename_map, inplace=True)

    # ğŸ”¢ Konwersja wartoÅ›ci liczbowych i procentÃ³w
    def clean_numeric(value):
        if isinstance(value, (int, float)):
            return value
        if isinstance(value, str):
            value = value.strip().replace(',', '')
            if value.endswith('B'): return float(value[:-1]) * 1e9
            if value.endswith('M'): return float(value[:-1]) * 1e6
            if value.endswith('K'): return float(value[:-1]) * 1e3
            if value.endswith('%'): return float(value[:-1])
            try:
                return float(value)
            except ValueError:
                return None
        return None

    for col in ['market_cap', 'p_e', 'price', 'change', 'volume']:
        if col in df_copy.columns:
            df_copy[col] = df_copy[col].apply(clean_numeric)
            if col == 'volume':
                df_copy[col] = df_copy[col].apply(lambda x: int(x) if x is not None else None)
    df_copy = df_copy.replace({np.nan: None, pd.NaT: None})
    return df_copy



def create_user(email: str, password: str, sb_url: str, sb_key: str) -> bool:
    """Tworzy nowego uÅ¼ytkownika w systemie uwierzytelniania Supabase."""
    try:
        sb = SupabaseHandler(sb_url, sb_key)
        response = sb.client.auth.sign_up({"email": email, "password": password})

        user = getattr(response, "user", None)
        error = getattr(response, "error", None)

        if user:
            logging.info(f"UÅ¼ytkownik {email} zostaÅ‚ pomyÅ›lnie zarejestrowany.")
            st.success("Rejestracja pomyÅ›lna! SprawdÅº email, aby zweryfikowaÄ‡ konto.")
            return True
        elif error:
            logging.error(f"BÅ‚Ä…d przy tworzeniu uÅ¼ytkownika: {error.message}")
            st.error(f"BÅ‚Ä…d przy tworzeniu uÅ¼ytkownika: {error.message}")
            return False
        return False

    except Exception as e:
        logging.exception(f"WyjÄ…tek przy tworzeniu uÅ¼ytkownika: {e}")
        st.error(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return False
