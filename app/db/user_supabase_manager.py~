# app/db/user_supabase_manager.py
import logging
import pandas as pd
import numpy as np
from datetime import date
from supabase import create_client, Client
import streamlit as st
from sqlalchemy.engine import URL
from sqlalchemy import create_engine


class SupabaseHandler:
    def __init__(self, url: str, key: str):
        if not url or not key:
            raise ValueError("Supabase URL and Key must be provided.")
        self.client: Client = create_client(url, key)
        self._checked_tables = set()

    def get_all_tickers_from_supabase(self):
        return self.client.table("ticker").select("*").execute().data

    def create_sqlalchemy_engine(self):
        """
        Tworzy silnik SQLAlchemy na podstawie danych wprowadzonych przez UŻYTKOWNIKA
        i zapisanych w st.session_state.
        """
        try:
            # POBIERAMY DANE Z SESJI UŻYTKOWNIKA!
            db_user = st.session_state["sb_db_user"]
            db_password = st.session_state["sb_db_password"]
            db_host = st.session_state["sb_db_host"]
            db_port = st.session_state["sb_db_port"]
            db_name = st.session_state["sb_db_name"]

            # Sprawdzamy, czy dane nie są puste
            if not all([db_user, db_password, db_host, db_port, db_name]):
                st.error("Nie wszystkie dane do połączenia z bazą danych zostały podane w konfiguracji.")
                return None

            db_url = URL.create(
                "postgresql+psycopg2",
                username=db_user,
                password=db_password,
                host=db_host,
                port=db_port,
                database=db_name,
            )
            engine = create_engine(db_url)
            logging.info("Pomyślnie utworzono silnik SQLAlchemy dla Supabase na podstawie danych z sesji.")
            return engine
        except KeyError:
            st.warning(
                "Proszę najpierw uzupełnić i zapisać dane do połączenia z bazą danych w zakładce konfiguracyjnej.")
            return None
        except Exception as e:
            st.error(f"Nie udało się utworzyć połączenia z bazą danych użytkownika: {e}")
            return None

    def check_and_inform(self, table_name: str = "stocks_data") -> bool:
        """
        Sprawdza, czy tabela istnieje. Jeśli nie, wyświetla jasne instrukcje dla użytkownika.
        Zwraca True, jeśli tabela istnieje i jest gotowa do użycia, w przeciwnym razie False.
        """
        create_table_sql = """
        -- Tworzy wymaganą tabelę do przechowywania danych giełdowych.
        CREATE TABLE IF NOT EXISTS public.stocks_data (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
            ticker TEXT,
            company TEXT,
            sector TEXT,
            industry TEXT,
            country TEXT,
            market_cap NUMERIC,
            p_e NUMERIC,
            price NUMERIC,
            change NUMERIC,
            volume BIGINT,
            import_date DATE
        );

        -- Włącza mechanizm Row Level Security dla tej tabeli (ważne dla bezpieczeństwa)
        ALTER TABLE public.stocks_data ENABLE ROW LEVEL SECURITY;

        -- Usuwa starą politykę, jeśli istnieje, aby uniknąć konfliktu
        DROP POLICY IF EXISTS "Public access for app users" ON public.stocks_data;

        -- Tworzy nową politykę, która pozwala KAŻDEMU (używającemu anon_key)
        -- na wykonywanie wszystkich operacji (SELECT, INSERT, UPDATE, DELETE).
        CREATE POLICY "Public access for app users"
        ON public.stocks_data
        FOR ALL
        USING (true)
        WITH CHECK (true);
        """

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostępna.")
            return True
        except Exception as e:
            logging.warning(f"Tabela '{table_name}' nie istnieje lub jest niedostępna. Błąd: {e}")

            st.error(f"Wymagana tabela '{table_name}' nie istnieje w Twojej bazie danych!", icon="🚨")
            st.warning(
                "**Aby aplikacja mogła zapisywać dane, potrzebna jest jednorazowa konfiguracja.**",
                icon="ℹ️"
            )

            st.markdown("""
            **Prosta instrukcja (zajmie 2 minuty):**
            1. Przejdź do swojego projektu na [Supabase.com](https://supabase.com/dashboard).
            2. W menu po lewej stronie kliknij **SQL Editor**.
            3. Kliknij **+ New query**.
            4. Skopiuj poniższy blok kodu i wklej go w całości do edytora.
            5. Kliknij zielony przycisk **RUN**.

            Po wykonaniu tych kroków **odśwież stronę aplikacji**.
            """)

            st.code(create_table_sql, language="sql")
            return False

    def _ensure_table_exists(self, table_name: str):
        if table_name in self._checked_tables:
            return

        create_table_sql = """
        CREATE TABLE IF NOT EXISTS public.stocks_data (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
            ticker TEXT,
            company TEXT,
            sector TEXT,
            industry TEXT,
            country TEXT,
            market_cap NUMERIC,
            p_e NUMERIC,
            price NUMERIC,
            change NUMERIC,
            volume BIGINT,
            import_date DATE
        );
        """

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostępna.")
            self._checked_tables.add(table_name)
        except Exception:
            st.warning(f"Tabela '{table_name}' nie znaleziona. Próbuję ją automatycznie utworzyć...", icon="🛠️")
            logging.warning(
                f"Tabela '{table_name}' nie znaleziona. Wywołuję RPC 'create_stocks_data_table_if_not_exists'.")

            try:
                self.client.rpc('create_stocks_data_table_if_not_exists', {}).execute()
                st.success(f"Tabela '{table_name}' została pomyślnie utworzona w bazie danych!", icon="✅")
                self._checked_tables.add(table_name)
            except Exception as rpc_error:
                logging.error(f"Krytyczny błąd podczas wywoływania RPC: {rpc_error}")
                st.error(f"Nie udało się automatycznie utworzyć tabeli '{table_name}'.", icon="❌")
                st.warning("Wklej poniższy SQL w Supabase SQL Editor i uruchom go (najbezpieczniejsze).", icon="ℹ️")
                st.code(create_table_sql, language="sql")
                raise RuntimeError(f"Failed to create table '{table_name}' via RPC.")

    def save_dataframe(self, df: pd.DataFrame, table_name: str = "stocks_data") -> int:
        try:
            self._ensure_table_exists(table_name)
        except RuntimeError as e:
            logging.error(str(e))
            return 0

        if df.empty:
            st.warning("Otrzymano pusty DataFrame. Nic nie zostało zapisane.")
            return 0

        df_to_save = df.copy()
        df_to_save["import_date"] = date.today().isoformat()
        df_to_save = df_to_save.replace({np.nan: None, pd.NaT: None})

        for col in ["id", "created_at", "idx"]:
            if col in df_to_save.columns:
                df_to_save.drop(columns=[col], inplace=True)

        valid_columns = [
            "ticker", "company", "sector", "industry", "country",
            "market_cap", "p_e", "price", "change", "volume", "import_date"
        ]
        existing_cols = [col for col in df_to_save.columns if col in valid_columns]
        missing_cols = [col for col in valid_columns if col not in df_to_save.columns]

        if missing_cols:
            st.warning(f"Brakujące kolumny w DataFrame: {missing_cols} – zostaną pominięte.", icon="⚠️")
        if extra_cols := [col for col in df_to_save.columns if col not in valid_columns]:
            st.info(f"Kolumny niewystępujące w bazie ({extra_cols}) zostały automatycznie odrzucone.", icon="ℹ️")

        df_to_save = df_to_save[existing_cols]

        records = df_to_save.to_dict(orient="records")
        saved_count = 0
        batch_size = 500

        st.info(f"Rozpoczynam zapis {len(records)} rekordów do tabeli '{table_name}'...")

        for i in range(0, len(records), batch_size):
            chunk = records[i:i + batch_size]
            try:
                response = self.client.table(table_name).insert(chunk).execute()
                if hasattr(response, "error") and response.error:
                    st.error(f"Błąd Supabase w trakcie zapisu (batch {i // batch_size + 1}): {response.error.message}")
                    logging.error(f"Supabase insert error: {response.error}")
                    break
                elif hasattr(response, "data"):
                    saved_count += len(response.data)
            except Exception as e:
                st.error(f"Wystąpił nieoczekiwany błąd podczas zapisu: {e}")
                logging.exception("Exception during Supabase insert batch.")
                break

        if saved_count > 0:
            st.success(f"✅ Zapisano {saved_count} rekordów do tabeli '{table_name}'.")
        else:
            st.error("❌ Zapis nie powiódł się. Sprawdź komunikaty o błędach powyżej.")

        return saved_count


def clean_and_transform_for_db(df: pd.DataFrame) -> pd.DataFrame:
    """Czyści i przekształca surowy DataFrame z Finviz do wstawienia do bazy danych."""
    if df.empty:
        return df

    df_copy = df.copy()

    # 🔧 Normalizujemy nazwy kolumn
    df_copy.columns = [
        col.lower().strip().replace(' ', '_').replace('.', '').replace('/', '_').replace('-', '_')
        for col in df_copy.columns
    ]

    # 🔁 Mapowanie nietypowych nazw kolumn na nasze standardy
    rename_map = {
        "market_cap": "market_cap",
        "marketcapitalization": "market_cap",
        "p_e": "p_e",
        "pe": "p_e",
        "pe_ratio": "p_e",
        "price": "price",
        "last": "price",
        "change": "change",
        "chg": "change",
        "volume": "volume",
        "vol": "volume"
    }
    df_copy.rename(columns=rename_map, inplace=True)

    # 🔢 Konwersja wartości liczbowych i procentów
    def clean_numeric(value):
        if isinstance(value, (int, float)):
            return value
        if isinstance(value, str):
            value = value.strip().replace(',', '')
            if value.endswith('B'): return float(value[:-1]) * 1e9
            if value.endswith('M'): return float(value[:-1]) * 1e6
            if value.endswith('K'): return float(value[:-1]) * 1e3
            if value.endswith('%'): return float(value[:-1])
            try:
                return float(value)
            except ValueError:
                return None
        return None

    for col in ['market_cap', 'p_e', 'price', 'change', 'volume']:
        if col in df_copy.columns:
            df_copy[col] = df_copy[col].apply(clean_numeric)
            if col == 'volume':
                df_copy[col] = df_copy[col].apply(lambda x: int(x) if x is not None else None)
    df_copy = df_copy.replace({np.nan: None, pd.NaT: None})
    return df_copy


def create_user(email: str, password: str, sb_url: str, sb_key: str) -> bool:
    """Tworzy nowego użytkownika w systemie uwierzytelniania Supabase."""
    try:
        sb = SupabaseHandler(sb_url, sb_key)
        response = sb.client.auth.sign_up({"email": email, "password": password})

        user = getattr(response, "user", None)
        error = getattr(response, "error", None)

        if user:
            logging.info(f"Użytkownik {email} został pomyślnie zarejestrowany.")
            st.success("Rejestracja pomyślna! Sprawdź email, aby zweryfikować konto.")
            return True
        elif error:
            logging.error(f"Błąd przy tworzeniu użytkownika: {error.message}")
            st.error(f"Błąd przy tworzeniu użytkownika: {error.message}")
            return False
        return False

    except Exception as e:
        logging.exception(f"Wyjątek przy tworzeniu użytkownika: {e}")
        st.error(f"Wystąpił nieoczekiwany błąd: {e}")
        return False
