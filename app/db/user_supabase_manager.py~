import logging
import pandas as pd
import numpy as np
from datetime import date
from supabase import create_client, Client
import streamlit as st


class SupabaseHandler:
    def __init__(self, url: str, key: str):
        if not url or not key:
            raise ValueError("Supabase URL and Key must be provided.")
        self.client: Client = create_client(url, key)
        self._checked_tables = set()

    def _ensure_table_exists(self, table_name: str):
        if table_name in self._checked_tables:
            return

        try:
            self.client.table(table_name).select("id", head=True).limit(1).execute()
            logging.info(f"Tabela '{table_name}' istnieje i jest dostÄ™pna.")
            self._checked_tables.add(table_name)
        except Exception:
            st.warning(f"Tabela '{table_name}' nie znaleziona. PrÃ³bujÄ™ jÄ… automatycznie utworzyÄ‡...", icon="ğŸ› ï¸")
            logging.warning(
                f"Tabela '{table_name}' nie znaleziona. WywoÅ‚ujÄ™ RPC 'create_stocks_data_table_if_not_exists'.")

            try:
                self.client.rpc('create_stocks_data_table_if_not_exists', {}).execute()

                st.success(f"Tabela '{table_name}' zostaÅ‚a pomyÅ›lnie utworzona w bazie danych!", icon="âœ…")
                logging.info(f"RPC zakoÅ„czone sukcesem. Tabela '{table_name}' powinna juÅ¼ istnieÄ‡.")
                self._checked_tables.add(table_name)
            except Exception as rpc_error:
                logging.error(f"Krytyczny bÅ‚Ä…d podczas wywoÅ‚ywania RPC do tworzenia tabeli: {rpc_error}")
                st.error(
                    f"Nie udaÅ‚o siÄ™ automatycznie utworzyÄ‡ tabeli '{table_name}'.",
                    icon="âŒ"
                )
                st.warning(
                    "Upewnij siÄ™, Å¼e funkcja `create_stocks_data_table_if_not_exists` zostaÅ‚a poprawnie dodana w edytorze SQL w panelu Supabase.",
                    icon="â„¹ï¸"
                )
                raise RuntimeError(f"Failed to create table '{table_name}' via RPC.")

    def save_dataframe(self, df: pd.DataFrame, table_name: str = "stocks_data") -> int:
        try:
            self._ensure_table_exists(table_name)
        except RuntimeError as e:
            logging.error(str(e))
            return 0

        if df.empty:
            st.warning("Otrzymano pusty DataFrame. Nic nie zostaÅ‚o zapisane.")
            return 0

        df_to_save = df.copy()
        df_to_save["import_date"] = date.today().isoformat()
        df_to_save = df_to_save.replace({np.nan: None, pd.NaT: None})
        records = df_to_save.to_dict(orient="records")

        saved_count = 0
        batch_size = 500

        st.info(f"Rozpoczynam zapis {len(records)} rekordÃ³w do tabeli '{table_name}'...")

        for i in range(0, len(records), batch_size):
            chunk = records[i:i + batch_size]
            try:
                response = self.client.table(table_name).insert(chunk).execute()
                if response.error:
                    st.error(f"BÅ‚Ä…d Supabase w trakcie zapisu (batch {i // batch_size + 1}): {response.error.message}")
                    logging.error(f"Supabase insert error: {response.error}")
                    break
                else:
                    saved_count += len(response.data)
            except Exception as e:
                st.error(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d sieci lub klienta podczas zapisu: {e}")
                logging.exception("Exception during Supabase insert batch.")
                break

        return saved_count


def clean_and_transform_for_db(df: pd.DataFrame) -> pd.DataFrame:
    """CzyÅ›ci i przeksztaÅ‚ca surowy DataFrame z Finviz do wstawienia do bazy danych."""
    if df.empty:
        return df

    df_copy = df.copy()

    df_copy.columns = [col.lower().replace(' ', '_').replace('.', '').replace('/', '_') for col in df_copy.columns]

    def clean_numeric(value):
        if isinstance(value, (int, float)):
            return value
        if isinstance(value, str):
            value = value.strip().replace(',', '')
            if value.endswith('B'): return float(value[:-1]) * 1e9
            if value.endswith('M'): return float(value[:-1]) * 1e6
            if value.endswith('K'): return float(value[:-1]) * 1e3
            if value.endswith('%'): return float(value[:-1])
        return value

    cols_to_process = ['market_cap', 'p_e', 'price', 'change', 'volume']
    for col in cols_to_process:
        if col in df_copy.columns:
            df_copy[col] = df_copy[col].apply(clean_numeric)
            df_copy[col] = pd.to_numeric(df_copy[col], errors='coerce')

    return df_copy.replace({np.nan: None, pd.NaT: None})


def create_user(email: str, password: str, sb_url: str, sb_key: str) -> bool:
    """Tworzy nowego uÅ¼ytkownika w systemie uwierzytelniania Supabase."""
    try:
        sb = SupabaseHandler(sb_url, sb_key)
        response = sb.client.auth.sign_up({"email": email, "password": password})

        if response.user:
            logging.info(f"UÅ¼ytkownik {email} zostaÅ‚ pomyÅ›lnie zarejestrowany.")
            st.success("Rejestracja pomyÅ›lna! SprawdÅº email, aby zweryfikowaÄ‡ konto.")
            return True
        elif response.error:
            logging.error(f"BÅ‚Ä…d przy tworzeniu uÅ¼ytkownika: {response.error.message}")
            st.error(f"BÅ‚Ä…d przy tworzeniu uÅ¼ytkownika: {response.error.message}")
            return False
        return False
    except Exception as e:
        logging.exception(f"WyjÄ…tek przy tworzeniu uÅ¼ytkownika: {e}")
        st.error(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return False
